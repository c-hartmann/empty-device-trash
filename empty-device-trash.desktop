#
# Add an entry to the Devices menus in the Taskbar
# to empty Trash before unmounting it.
#

# Installation: Copy me to: ~/.local/share/solid/actions/

# TODO
#
# * Use "Do not ask again" option?
#
# * Can we disable the availability of this action, when device is not yet mounted?
# > Seems, Plasma mounts the device automatically when we access it, so there na
#   state 'not mounted' we would to take into account.
#
# * make use of %f if we have it:
#   from: https://techbase.kde.org/Development/Tutorials/Solid/Device_Actions ...
#   Executing actions
#   A matching action can be selected for execution by the user. When that happens,
#   the command line in the Exec key of the action is executed given the device
#   as a parameter. The location and value of the parameter is specified in the
#   following way:
#
#   %f
#       Device mount point location, if applicable
#   %d
#       Device special file path
#
# > so this bit more omplex approach to read the mount point is *not* required:
#   mount_point="$(command findmnt --noheadings --output TARGET $block_device)"

# for some unkwon reason $ ls -1 <mount_point>/.Trash-* fails, although a later
# $ rm <mount_point>/.Trash-*/files/ succeeds. So .Trash-1000 keeps "hard coded".
# bash internal printf command comes to a rescue.

[Desktop Entry]
Type=Service
X-KDE-Action-Custom=true
# aaaa, these Solid-Predicates drive me nuts. If someone reads this and knows an URL with a complete documentation .. please contact me: hartmann.christian@gmail.com
# X-KDE-Solid-Predicate=[ [ [ StorageVolume.ignored == false AND StorageVolume.usage == 'FileSystem' ] AND [ StorageDrive.driveType != 'CdromDrive' AND StorageVolume.removable == true ] ]
# X-KDE-Solid-Predicate=[ [ [ StorageVolume.ignored == false AND StorageVolume.usage == 'FileSystem' ] AND StorageVolume.removable == true ]
X-KDE-Solid-Predicate=[ [ StorageVolume.ignored == false AND StorageVolume.usage == 'FileSystem'] OR [ IS StorageAccess AND StorageDrive.driveType == 'Disk'] ]
# some reasonable icons and the one we use:
# Icon=trash-empty-symbolic
# Icon=user-trash-full-symbolic
# Icon=user-trash-symbolic
# Icon=user-trash-full-symbolic
Icon=albumfolder-user-trash-symbolic
Actions=EmptyTrash

[Desktop Action EmptyTrash]
Name=Empty Device Trash
Icon=albumfolder-user-trash-symbolic
# NOTE: block_device="%d"; mount_point="%f";
Exec=bash -c 'block_device="%d"; mount_point="%f"; user_id=$UID; typeset -a udisksctl_out; spacer="          "; separator="————————————————————"; function error_exit { kdialog --error "$1" 1>/dev/null 2>&1; exit 1; }; function decode_url { path="$1"; (IFS="+"; echo -e ${path//%/\\x}""); }; function collect_pathes { trash_dir="$1"; cd "$trash_dir"; for if in "${trash_dir}"/info/*.trashinfo; do orig_path=$(grep "^Path=" "$if"); orig_path=${orig_path#Path=}; orig_path=$(decode_url "$orig_path"); printf "%s\n" "$orig_path"; done; }; udisksctl_out=($(command udisksctl info --block-device $block_device | grep "IdLabel:")); unset udisksctl_out[0]; block_device_label="${udisksctl_out[@]}"; files_count=$(cd "${mount_point}/.Trash-${user_id}/info/"; command ls -1 | command wc -l); sorry_message="It seems as if there are no files or directories to delete in the Trash on: ${block_device_label}${spacer}"; test $files_count -eq 0 && kdialog --title "No File(s) to Delete" --ok-label "Dismiss" --sorry "$sorry_message" 1>/dev/null 2>&1 && exit 1; warning_message="Delete following $files_count file(s) permanently from trash on: ${block_device_label}?${spacer}\n\n${separator}\n$(collect_pathes "${mount_point}/.Trash-${user_id}")\n${separator}\n\nTHIS ACTION CANNOT BE UNDONE.\n\n"; kdialog --title "Confirm Delete Permanently" --yes-label "Delete Permanently" --no-label "Cancel" --warningyesno "$warning_message" 1>/dev/null 2>&1; kdialog_return_value=$?; test $kdialog_return_value -eq 0 && command rm -rf "${mount_point}/.Trash-${user_id}"/files/* && command rm -rf "${mount_point}/.Trash-${user_id}"/info/*;'
